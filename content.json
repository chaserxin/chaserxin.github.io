[{"title":"Collection与Iterator的remove()方法区别与ConcurrentModificationException异常","date":"2017-04-09T02:53:00.000Z","path":"2017/04/09/Collection与Iterator的remove()方法区别与ConcurrentModificationException异常/","text":"在我的上一篇文章 Java中三种遍历Collection中元素的方法(Iterator、forEach、for循环)对比 中提到Iterator和forEach循环在遍历Collection中元素时最大的差别就是在方法remove()上,由于在Iterator的remove()方法中维护一个标志位,所以删除元素时不会出现异常，所以本篇文章就深入Collection与Iterator的源码看看内部究竟是如何实现的。 一. Collection及其实现类ArrayList的部分源码1.Collection内部源码首先我们来看一下Collection内部源码（为方便分析，此处只展示与本篇文章有关的部分）：12345678910public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; boolean remove(Object o); Iterator&lt;E&gt; iterator(); /** * 此处省去其他方法定义 */&#125; 可以看到Collection是一个接口，内部定义了remove()与iterator()方法。 2.ArrayList内部源码由于Collection接口内部无具体实现，所以我们来看Collection的一个最常用的实现类ArrayList内部源码（为方便分析，此处只展示与本篇文章有关的部分）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /* -----------------------我是便于观察的分割线----------------------- */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * 此处省去其他方法定义 */&#125; 在ArrayList中并没有直接实现Collection接口，而是通过继承AbstractList抽象类，而AbstractList抽象类又继承了AbstractCollection抽象类，最终AbstractCollection抽象类实现Collection接口；所以ArrayList间接实现了Collection接口，有兴趣的大佬可以自己去研究下为什么这样子设计，在这里就不多加讨论。 可以看到在ArrayList中有实现remove()与iterator()方法，并且通过iterator()方法得到的内部类Itr实现了Iterator接口，在Itr内部类中也有实现remove()方法，下面就来具体的探讨其中的区别。 二. ArrayList的remove()方法分析1.remove()方法在ArrayList的remove()方法内部的实现主要是通过循环找到元素的下标， 然后调用私有的fastRemove()方法：1fastRemove(index); remove()方法没啥好讲的，关键在于调用的fastRemove()方法上。 2.fastRemove()方法fastRemove()方法中会先修改modCount的值，然后将通过复制一个新的数组的方法将原来index位置上的值覆盖掉，最后数组大小减一。我们重点关注fastRemove()方法的第一行代码：1modCount++; 也就是每次调用remove()方法都会使modCount的值加一。那么modCount变量又是什么呢？ 3.modCount变量modCount在ArrayList中没有定义，是在ArrayList的父类AbstractList抽象类中定义的：12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; protected transient int modCount = 0; /** * 此处省去其他方法定义 */&#125; modCount的作用是记录操作（添加删除）ArrayList中元素的次数（这个很关键），每次操作ArrayList中元素后就会使modCount加一。 三. Iterator的remove()方法分析看源码可知ArrayList通过iterator()方法得到了一个内部类Itr，这个内部类实现了Iterator接口，我们重点分析内部类Itr中的实现。 1.expectedModCount 变量在内部类Itr中定义了一个变量expectedModCount ：1int expectedModCount = modCount; expectedModCount 只在new一个Itr对象时初始化为modCount 2.next()与remove()方法在调用Itr对象的next()与remove()方法时第一步会先调用checkForComodification()方法。1checkForComodification(); 并且在remove()方法中会调用ArrayList.this.remove(lastRet)方法(也就是具体的ArrayList对象的remove()方法，上面我们讲过，在ArrayList对象的remove()方法中会使得modCount的值加一)，然后修改expectedModCount 的值为modCount。 3.checkForComodification()方法checkForComodification()会检查expectedModCount与modCount 是否相等，如果不相等就会抛出ConcurrentModificationException异常。1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 四. 总结通过上面的分析我们可以得出，Collection与Iterator的remove()方法最大的区别就是：Iterator的remove()方法会在删除元素后将modCount 的值赋值给expectedModCount，使其又相等。 1.如果我们在Iterator循环中调用Collection的remove()方法123456789public static void display(Collection&lt;Object&gt; collection) &#123; Iterator&lt;Object&gt; it = collection.iterator(); // 会抛出ConcurrentModificationException异常 while(it.hasNext()) &#123; Object obj = it.next(); collection.remove(obj ); &#125;&#125; 由于collection.remove(obj )只会删除obj元素后将modCount 的值加一，并不会修改expectedModCount的值，所以当下一次调用it.next()方法时发现modCount != expectedModCount，将抛出ConcurrentModificationException异常。 2.如果我们在Iterator循环中调用Iterator的remove()方法12345678public static void display(Collection&lt;Object&gt; collection) &#123; Iterator&lt;Object&gt; it = collection.iterator(); // 正常执行 while(it.hasNext()) &#123; Object obj = it.next(); it.remove(obj ); &#125;&#125; 由于it.remove(obj )会在删除obj元素后将modCount 的值加一，并将expectedModCount重新赋值为modCount ，使其相等，所以当下一次调用it.next()方法时发现modCount == expectedModCount，正常执行。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中三种遍历Collection中元素的方法(Iterator、forEach、for循环)对比","date":"2017-04-09T02:15:30.000Z","path":"2017/04/09/Java中三种遍历Collection中元素的方法(Iterator、forEach、for循环)对比1/","text":"[注]仅对比此三种方法在实现下面的此功能中的区别在实现遍历并选择序列中的对象,而客户端程序员不必知道或关心该序列底层的结构 (摘自Java编程思想第四版)也就是说在使用此方法时,不必考虑需要遍历的是ArrayList、LinkedList还是HashSet中的元素 一. 三种方法实现方式代码1.1 Iterator123456public static void display(Iterator&lt;Object&gt; it) &#123; while(it.hasNext()) &#123; Object obj = it.next(); System.out.println(obj); &#125;&#125; 1.2 forEach12345public static void display(Collection&lt;Object&gt; co) &#123; for (Object obj : co) &#123; System.out.print(obj); &#125;&#125; 1.3 for循环123456public static void display(Collection&lt;Object&gt; co) &#123; Object[] obj = co.toArray(new Object[co.size()]); for (int i=0; i&lt;obj.length; i++) &#123; System.out.print(s[i]); &#125; &#125; 二. 三种方法实现方式对比2.1 for循环分析 在for循环中实现中,由于Collection接口本身没有获取Collection中元素的方法,所以必须将Collection先转化为一个Array再进行遍历(Collection的不同实现中有不同的获取元素的方法,由于此处是讨论的是通用的实现方法,所以不考虑具体的实现),因此需要新建一个数组(实际上用 T[] toArray(T[] a) 方法实现是需要创建两个数组的)用来容纳原Collection中的所有元素,这样子增加了额外的开销,另一方面由于数组中的元素是由Collection中的元素复制过来的,所以使得我们对原Collection中的元素进行操作(如删除元素)变得困难(虽然可以使用Collection中的remove(Object o)方法删除元素,但是方法只是删除Collection中第一个与o匹配的元素,过于局限)。 2.2 forEach分析 forEach是 JDK1.5 新加入的一个功能,用于更简单的实现对数组或者Collection对象(实现iterable接口的集合)进行遍历,其实在实现对Collection对象的遍历时,编译器对forEach的实现用的就是Iterator： 123for(Object obj : collection) &#123;&#125;//相当于：for(Iterator iterator = collection.iterator(); iterator.hasNext(); ) &#123;&#125; 但是在forEach实现中如果需要对Collection中的元素进行操作(如删除元素),那么系统将会抛出ConcurrentModificationException异常,这也是他与Iterator实现方式的唯一区别 2.3 Iterator分析 Iterator是Java专门为了实现对Collection中的元素的遍历而设计的一个接口,使用Iterator进行遍历时,不用担心此Collection容器的具体是现是什么,关于Iterator的详细介绍Iterator的中的方法: (1)next()获取序列中的下一个元素(2) hasNext()检查序列中是否还有元素(3) remove()将迭代器新进返回的元素删除 其中Iterator与forEach最大的差别就是在方法remove()上,由于在Iterator的remove()方法中维护一个标志位,所以删除元素时不会出现异常 三. 总结 通过上面的代码,可以很清楚的看到在实现一个通用的遍历Collection中的元素时,Iterator与forEach这两种实现比for循环的代码更简洁、实现更容易。 在实际使用过程中,如只是单纯的对Collection中的元素进行遍历,那么使用forEach相对来说比较方面,如果需要在遍历的过程中对Collection中的元素进行操作(如删除元素),那么无疑必须使用Iterator 续集：从源码上分析操作(删除)元素时为什么建议Iterator循环：Collection与Iterator的remove()方法区别与ConcurrentModificationException异常","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]