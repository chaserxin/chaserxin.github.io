[{"title":"利用Sentris特价服务器和Shadowsocks搭建自己的梯子","date":"2017-04-09T03:06:30.000Z","path":"2017/04/09/利用Sentris特价服务器和Shadowsocks搭建自己的梯子/","text":"博主之前一直使用蓝灯fq，由于蓝灯的速度实在太渣以及流量太少（毕竟免费），并且看过一些文章说免费的代理可能存在py，在无法忍受的前提下，决定自己动手搭建梯子。最开始是找到了一位大牛的博客(老高的技术博客)，里面推荐了几个国外的vps，也不是很贵，本来准备入手了，但是闲着无聊多看了下底下的评论，发现另外一位 dalao(尼玛博客)推荐了一个非常便宜的Sentris服务器，顿时眼前一亮（主要是没钱），于是开启了愉快的造梯子之旅。 一、购买Sentris特价服务器Sentris是一家老牌美国IDC，之前也有用FreeServer.US的牌子推出过免费的vps，不过现在已经不提供了免费的了，但是现在还有活动，最低可以用$5.99 USD买三年的一台很小的vps，只有64M内存（博主买的就是这个），还是很实惠的。 【注】：由于博主只是平时fq不怎么看视频，所以用64M的内存搭建一个梯子平时用用并且不看高清视频还是没问题的，如果你有到YouTube上看1080P视频的需求，亲测这个64M内存的vps是绝对不行的 1.Sentris特价服务器购买地址：http://freeserver.us/plans/ 2.在弹出来的页面上点击：New LXC/OpenVZ SATA RAID from $0.16/mo* 3.在出现的面板中，点击：Order Now 4.在弹出的新网页中选择第一个vps：New OVZ SATA SEA Custom - Based VPS: New OpenVZ 5.然后点击Continue按钮，进入一个新窗口选择vps的配置，vps的配置一共有四项：Product/Service、Configurable Options、Addons、Additional Required Information。 配置Product/Service：产品的名字和产品的描述，这里只需要将Billing Cycle这一项改成购买36个月 配置Configurable Options：vps的配置选项，改成和下图一样就行了，其实主要就是改了Bandwidth in MB，因为默认的带宽是500G每个月的，需要多交钱，实际上250G就够了。 配置Addons：这个选项是额外的扩展，可以新加硬盘、内存和交换区，但是要另加钱！！！，默认什么都不加就好了。 配置Additional Required Information：一些附加的必须的信息，你可以把它当做是一个用户协议，你只能每一项的按照它的选择来，不然不卖给你！ 6.点击Continu按钮，会弹出购物车。如果按照我的教程一步一步的点击的话一共是$5.99 USD。 7.然后点击Checkout按钮提交订单，如果你没注册的话会先让你填信息注册。然后就是付款了，这里付款是不能使用支付宝的，只能使用PayPal国际版（中国版也不能用）、比特币、信用卡或者Visa卡等。由于博主这些都没有（穷逼学生），只能使用万能的淘宝，淘宝搜索代付就行了，不过需要几块钱的手续费，反正博主最后48块钱人民币搞定的（5.99美元=41.2453人民币元） 8.付款完成之后你就可以点击Service的My Service选项查看自己的服务器，点击你的服务器就可以看到服务器的控制面板（控制面板的图就不放了），里面有服务器的ip、登录账号密码等等所有信息，可以使用ssh工具登录服务器进行第二步操作了！ 二、搭建Shadowsocks服务Shadowsocks是一个使用Socks5代理方式的代理服务。Shadowsocks分为服务器端和客户端。在使用之前，需要先将服务器端部署到服务器上面，然后通过客户端连接并创建本地代理。本节将从服务器端搭建与客户端搭建两方面来讲。 Shadowsocks的github地址：https://github.com/shadowsocks 1.搭建Shadowsocks服务端 首先用ssh工具登录到你的服务器，然后使用以下命令查看一下你的linux发行版是什么，如果按照我的教程一步一步的来，应该都是CentOS发行版，下面安装ShadowSocks的命令也是适用于CentOS发行版的。（如果选择了Debian发行版的系统，自己去Shadowsocks的github上查找相关搭建方法） 1cat /etc/issue 使用yum命令安装ShadowSocks服务器端（这里不要使用Shadowsocks的github地址上提供的安装办法，因为我们买的sentris服务器安装的python版本太低了） 12345# 首先安装python包管理工具和安装pipyum install python-setuptools &amp;&amp; easy_install pip# 使用pip直接安装shadowsocks服务器端pip install shadowsocks 我们使用配置文件的方式配置ShadowSocks服务器端，需要自己创建配置文件/etc/shadowsocks.json 12345678910111213141516# 使用touch命令在etc目录下创建配置文件/etc/shadowsocks.jsontouch /etc/shadowsocks.json# 使用vi写入配置参数vi /etc/shadowsocks.json# 写入的参数如下：&#123;\"server\":\"my_server_ip\",\"server_port\":8388,\"local_address\":\"127.0.0.1\",\"local_port\":1080,\"password\":\"mypassword\",\"timeout\":300,\"method\":\"rc4-md5\"&#125; 各字段说明：（更多配置见这里） server:服务器IP server_port:服务器端口，一般设置为8388 local_address:本地地址，一般设置为127.0.0.1 local_port:本地端端口，一般设置为1080 password:用来加密的密码 timeout:超时时间（秒） method:加密方法，可选择aes-256-cfb，des-cfb， rc4-md5”等，默认的是aes-256-cfb，推荐使用更快的rc4-md5 使用配置文件在后台运行Shadowsocks服务 12345# 后台启动ssserver -c /etc/shadowsocks.json -d start# 关闭服务ssserver -c /etc/shadowsocks.json -d stop 2.安装Shadowsocks客户端 首先访问Shadowsocks的github地址下载最新版本的Shadowsocks客户端地址：https://github.com/shadowsocks/shadowsocks-windows/releases 下载好之后双击exe打开（绿色版，没有安装过程），输入前面在Shadowsocks服务端配置文件中配置的信息，包括服务器地址、服务器端口、密码、加密方式、超时和代理端口，输入完成之后点击确定即可。 右键点击右下角的Shadowsocks小飞机图标，选择启动系统代理，并且在系统代理模式那里选择PAC模式（在PAC模式下系统会自动切换代理，如果访问的是墙内的网站，则不会使用代理，如果访问墙外的网站，则使用代理；在全局模式下则全部使用代理），最后选择开机启动，这样子就不用每次开机都要手动启动Shadowsocks客户端了。 这样子本地Shadowsocks服务器就已经安装成功了，如果使用IE浏览器的话就可以正常的访问墙外的世界了，但是博主使用的是Chrome浏览器，还不能直接fq，还需要进一步的设置。 三、Chrome浏览器设置自动切换代理上网这里需要使用Chrome浏览器的一个代理管理插件——SwitchyOmega，这个插件能实现自动根据URL来决定是否使用代理。 正常来说运行了Shadowsocks后就可以直接访问Chrome应用商店安装了，在应用商店上面搜索SwitchyOmega，然后添加至Chrome即可。 安装完成之后打开SwitchyOmega插件后，选择新建情景模式，情景模式名称随便填，我这里填为proxy，类型选择为代理服务器。（由于我已经存在一个名为proxy的情景模式了，所以会提示已存在） 修改名为proxy的情景模式的配置，代理协议选择SOCKS5，代理服务器为127.0.0.1，代理端口为1080。 选择右边的自动切换/auto switch进行自动切换设置，在切换规则中先选择规则列表规则，然后将情景模式设置成proxy，然后设置默认情景模式为直连模式，在下面的*规则列表设置中选择AutoProxy，然后填入网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt点击立即更新情景模式即可。 最后是最关键的一步，在浏览器右上角点击插件按钮，然后选择自动切换规则模式，这样只要在规则列表里面的网站都会fq访问。对于没在翻墻规则里面的网站，可以自己添加规则（无法访问的时候插件那图标会有显示，点击后就可以看到快速添加方法）。 主要参考文章：CentOS6.6安装ShadowSocks服务端Chrome+SwitchyOmega+Shadowsocks 图文教程完整篇","tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://yoursite.com/tags/翻墙/"}]},{"title":"Collection与Iterator的remove方法区别与ConcurrentModificationException异常","date":"2017-04-09T02:53:00.000Z","path":"2017/04/09/Collection与Iterator的remove方法区别与ConcurrentModificationException异常/","text":"在我的上一篇文章 Java中三种遍历Collection中元素的方法Iterator、forEach、for循环对比 中提到Iterator和forEach循环在遍历Collection中元素时最大的差别就是在方法remove()上,由于在Iterator的remove()方法中维护一个标志位,所以删除元素时不会出现异常，所以本篇文章就深入Collection与Iterator的源码看看内部究竟是如何实现的。 一. Collection及其实现类ArrayList的部分源码1.Collection内部源码首先我们来看一下Collection内部源码（为方便分析，此处只展示与本篇文章有关的部分）：12345678910public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; boolean remove(Object o); Iterator&lt;E&gt; iterator(); /** * 此处省去其他方法定义 */&#125; 可以看到Collection是一个接口，内部定义了remove()与iterator()方法。 2.ArrayList内部源码由于Collection接口内部无具体实现，所以我们来看Collection的一个最常用的实现类ArrayList内部源码（为方便分析，此处只展示与本篇文章有关的部分）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; /* -----------------------我是便于观察的分割线----------------------- */ public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; /** * 此处省去其他方法定义 */&#125; 在ArrayList中并没有直接实现Collection接口，而是通过继承AbstractList抽象类，而AbstractList抽象类又继承了AbstractCollection抽象类，最终AbstractCollection抽象类实现Collection接口；所以ArrayList间接实现了Collection接口，有兴趣的大佬可以自己去研究下为什么这样子设计，在这里就不多加讨论。 可以看到在ArrayList中有实现remove()与iterator()方法，并且通过iterator()方法得到的内部类Itr实现了Iterator接口，在Itr内部类中也有实现remove()方法，下面就来具体的探讨其中的区别。 二. ArrayList的remove()方法分析1.remove()方法在ArrayList的remove()方法内部的实现主要是通过循环找到元素的下标， 然后调用私有的fastRemove()方法：1fastRemove(index); remove()方法没啥好讲的，关键在于调用的fastRemove()方法上。 2.fastRemove()方法fastRemove()方法中会先修改modCount的值，然后将通过复制一个新的数组的方法将原来index位置上的值覆盖掉，最后数组大小减一。我们重点关注fastRemove()方法的第一行代码：1modCount++; 也就是每次调用remove()方法都会使modCount的值加一。那么modCount变量又是什么呢？ 3.modCount变量modCount在ArrayList中没有定义，是在ArrayList的父类AbstractList抽象类中定义的：12345678public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; protected transient int modCount = 0; /** * 此处省去其他方法定义 */&#125; modCount的作用是记录操作（添加删除）ArrayList中元素的次数（这个很关键），每次操作ArrayList中元素后就会使modCount加一。 三. Iterator的remove()方法分析看源码可知ArrayList通过iterator()方法得到了一个内部类Itr，这个内部类实现了Iterator接口，我们重点分析内部类Itr中的实现。 1.expectedModCount 变量在内部类Itr中定义了一个变量expectedModCount ：1int expectedModCount = modCount; expectedModCount 只在new一个Itr对象时初始化为modCount 2.next()与remove()方法在调用Itr对象的next()与remove()方法时第一步会先调用checkForComodification()方法。1checkForComodification(); 并且在remove()方法中会调用ArrayList.this.remove(lastRet)方法(也就是具体的ArrayList对象的remove()方法，上面我们讲过，在ArrayList对象的remove()方法中会使得modCount的值加一)，然后修改expectedModCount 的值为modCount。 3.checkForComodification()方法checkForComodification()会检查expectedModCount与modCount 是否相等，如果不相等就会抛出ConcurrentModificationException异常。1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 四. 总结通过上面的分析我们可以得出，Collection与Iterator的remove()方法最大的区别就是：Iterator的remove()方法会在删除元素后将modCount 的值赋值给expectedModCount，使其又相等。 1.如果我们在Iterator循环中调用Collection的remove()方法123456789public static void display(Collection&lt;Object&gt; collection) &#123; Iterator&lt;Object&gt; it = collection.iterator(); // 会抛出ConcurrentModificationException异常 while(it.hasNext()) &#123; Object obj = it.next(); collection.remove(obj ); &#125;&#125; 由于collection.remove(obj )只会删除obj元素后将modCount 的值加一，并不会修改expectedModCount的值，所以当下一次调用it.next()方法时发现modCount != expectedModCount，将抛出ConcurrentModificationException异常。 2.如果我们在Iterator循环中调用Iterator的remove()方法12345678public static void display(Collection&lt;Object&gt; collection) &#123; Iterator&lt;Object&gt; it = collection.iterator(); // 正常执行 while(it.hasNext()) &#123; Object obj = it.next(); it.remove(obj ); &#125;&#125; 由于it.remove(obj )会在删除obj元素后将modCount 的值加一，并将expectedModCount重新赋值为modCount ，使其相等，所以当下一次调用it.next()方法时发现modCount == expectedModCount，正常执行。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java中三种遍历Collection中元素的方法Iterator、forEach、for循环对比","date":"2017-04-09T02:15:30.000Z","path":"2017/04/09/Java中三种遍历Collection中元素的方法Iterator、forEach、for循环对比/","text":"[注]仅对比此三种方法在实现下面的此功能中的区别在实现遍历并选择序列中的对象,而客户端程序员不必知道或关心该序列底层的结构 (摘自Java编程思想第四版)也就是说在使用此方法时,不必考虑需要遍历的是ArrayList、LinkedList还是HashSet中的元素 一. 三种方法实现方式代码1.1 Iterator123456public static void display(Iterator&lt;Object&gt; it) &#123; while(it.hasNext()) &#123; Object obj = it.next(); System.out.println(obj); &#125;&#125; 1.2 forEach12345public static void display(Collection&lt;Object&gt; co) &#123; for (Object obj : co) &#123; System.out.print(obj); &#125;&#125; 1.3 for循环123456public static void display(Collection&lt;Object&gt; co) &#123; Object[] obj = co.toArray(new Object[co.size()]); for (int i=0; i&lt;obj.length; i++) &#123; System.out.print(s[i]); &#125; &#125; 二. 三种方法实现方式对比2.1 for循环分析 在for循环中实现中,由于Collection接口本身没有获取Collection中元素的方法,所以必须将Collection先转化为一个Array再进行遍历(Collection的不同实现中有不同的获取元素的方法,由于此处是讨论的是通用的实现方法,所以不考虑具体的实现),因此需要新建一个数组(实际上用 T[] toArray(T[] a) 方法实现是需要创建两个数组的)用来容纳原Collection中的所有元素,这样子增加了额外的开销,另一方面由于数组中的元素是由Collection中的元素复制过来的,所以使得我们对原Collection中的元素进行操作(如删除元素)变得困难(虽然可以使用Collection中的remove(Object o)方法删除元素,但是方法只是删除Collection中第一个与o匹配的元素,过于局限)。 2.2 forEach分析 forEach是 JDK1.5 新加入的一个功能,用于更简单的实现对数组或者Collection对象(实现iterable接口的集合)进行遍历,其实在实现对Collection对象的遍历时,编译器对forEach的实现用的就是Iterator： 123for(Object obj : collection) &#123;&#125;//相当于：for(Iterator iterator = collection.iterator(); iterator.hasNext(); ) &#123;&#125; 但是在forEach实现中如果需要对Collection中的元素进行操作(如删除元素),那么系统将会抛出ConcurrentModificationException异常,这也是他与Iterator实现方式的唯一区别 2.3 Iterator分析 Iterator是Java专门为了实现对Collection中的元素的遍历而设计的一个接口,使用Iterator进行遍历时,不用担心此Collection容器的具体是现是什么,关于Iterator的详细介绍Iterator的中的方法: (1)next()获取序列中的下一个元素(2) hasNext()检查序列中是否还有元素(3) remove()将迭代器新进返回的元素删除 其中Iterator与forEach最大的差别就是在方法remove()上,由于在Iterator的remove()方法中维护一个标志位,所以删除元素时不会出现异常 三. 总结 通过上面的代码,可以很清楚的看到在实现一个通用的遍历Collection中的元素时,Iterator与forEach这两种实现比for循环的代码更简洁、实现更容易。 在实际使用过程中,如只是单纯的对Collection中的元素进行遍历,那么使用forEach相对来说比较方面,如果需要在遍历的过程中对Collection中的元素进行操作(如删除元素),那么无疑必须使用Iterator 续集：从源码上分析操作(删除)元素时为什么建议Iterator循环：Collection与Iterator的remove方法区别与ConcurrentModificationException异常","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]}]